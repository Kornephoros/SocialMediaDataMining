import csv
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import re
import scipy.sparse as sparse
import scipy.io
import time

'''
    The Analytics class contains many methods for crunching data that has been generated by the aggregators of this program.

    As this grows it might be wise to break this into multiple classes.
'''
class Analytics():

    def __init__(self):
        self.posts_to_analyze = list()
        self.users = list()
        self.weight = list(tuple())
        self.count = 0

        self.post_ratios = list()
        pass

    # This method will determine the type of post that is passed to it.
    def determine_type(self, file_name):
        if "likes" in file_name:
            return "likes"
        elif "comments" in file_name:
            return "comments"
        elif "posts" in file_name:
            return "posts"
        else:
            return "bad"

    # The analyze function will read the CSV passed to it and plot the frequency of likes / comments / posts
    def analyze(self, csvfile):
        type_of_file = self.determine_type(csvfile)
        if type_of_file is 'bad':
            return
        ds = pd.read_csv(csvfile)
        assert isinstance(ds, pd.DataFrame)
        plt.interactive(False)

        # This block creates a dataset of the counts within the csvfile passed and plots it.
        counts_only = ds['count']
        with plt.xkcd():
            plt.figure(1)
            plt_ret = plt.hist(counts_only, label='Frequency of '+type_of_file, range=(1, 22), bins=21)
            plt.clf()
            plt.bar(plt_ret[1][1:-1] - 0.4, plt_ret[0][1:]) # Bar graph, from 1 : the end. -0.4 to center the chart.
            plt.xticks(np.arange(22))
            plt.title(type_of_file + ' for posts')
            plt.legend()
            plt.show()
        print ds

    # This will extract the post ID from the filename of a CSV file.
    def determine_posts(self, csvfile):
        try:
            regex = re.compile("([0-9])+_+([0-9])+")   # Gathers the post ID from a string Ex: 5556667231_32144112
            post_id = regex.match(csvfile).group()
            if post_id in self.posts_to_analyze:
                pass
            else:
                self.posts_to_analyze.append(post_id)
        except AttributeError:
            pass # An input did not match the Regex arg.

    # This will determine the unique users in a file
    def determine_users(self, file_name):
        with open(file_name, 'rb') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                user_id = row['id']
                if user_id in self.users:
                    pass
                else:
                    self.users.append(user_id)
        self.count += 1
        print self.count

    # This will initialize the weight array to a [users] X [ posts] DataFrame.
    def initialize_weights(self):
        self.weight = pd.DataFrame(0, index = self.users, columns = self.posts_to_analyze) # Creates a DataFrame of size [users X posts] and fills with 0s

    # This will fill the weights array with the values corresponding to the impressions that user has made on a post.
    def determine_weight(self, file_name):
        regex = re.compile("([0-9])+_+([0-9])+")   # Gathers the post ID from a string Ex: 5556667231_32144112
        post_id = regex.match(file_name).group()

        type = self.determine_type(file_name)
        with open(file_name, 'rb') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                user_id = row['id']

                if type == "likes":
                    if self.weight.ix[user_id, post_id] == 0.5:   # User already liked
                        pass # Cap off likes at 0.5
                    elif self.weight.ix[user_id, post_id] == 0:   # So far, only liked
                        self.weight.ix[user_id, post_id] = 0.5
                    elif self.weight.ix[user_id, post_id] == -1:  # Commented and liked
                        self.weight.ix[user_id, post_id] = 1.5
                    #print "Successful like parsing of post " + post_id + " with user " + user_id
                elif type == "comments":
                    if self.weight.ix[user_id, post_id] >= 0.5:     # User already liked / maybe commented already
                        self.weight.ix[user_id, post_id] = 1.5
                    else:                                         # Otherwise, comment detected with no paired like
                        self.weight.ix[user_id, post_id] = -1.0
                else:
                    print "something went wrong during weight analysis"

    # Write the weight DataFrame to a sparse matrix, and then write it to an .mtx file.
    def write_to_matrix(self):
        sparse_m = sparse.csr_matrix(self.weight)
        hour = time.strftime("%H-%M")
        scipy.io.mmwrite("./DataFrameSparse_{0}.mtx".format(hour), sparse_m)


    # This will initialize the ratios DataFrame in a [posts] X [4] frame.
    def initialize_ratios(self):
        self.post_ratios = pd.DataFrame(0, index = self.posts_to_analyze, columns = ["likes", "comments", "ratio", "total_impressions"])

    # This will find the total post counts within a csv file.
    def find_post_counts(self, file_name):
        try:
            type = self.determine_type(file_name)
            regex = re.compile("([0-9])+_+([0-9])+")   # Gathers the post ID from a string Ex: 5556667231_32144112
            post_id = regex.match(file_name).group()
            count = 0
            with open(file_name, 'rb') as csvfile:
                for i, l in enumerate(csvfile):
                    pass
                count = i + 1
            self.post_ratios.ix[post_id, type] = count
        except AttributeError:
            pass

    # This will calculate and return the ratios of likes, comments, and impressions within the post ratios Data Frame.
    def calculate_ratios(self):
        try:
            for index, row in self.post_ratios.iterrows():
                num_likes = self.post_ratios[index, "likes"]
                num_comments = self.post_ratios[index, "comments"]
                self.post_ratios.ix[index, "total_impressions"] = num_likes + num_comments
                self.post_ratios.ix[index, "ratio"] = num_likes / num_comments
        except Exception:
            pass